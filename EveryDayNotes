useEffect vs useLayoutEffect

useEffect jest uzywany do wiekszosci przypadkow
jakimi sa fetchowanie danych, manualna manipulacja
DOM'em. UseEffect powinien byc uzywany, gdy efekt
NIE WPŁYWA NA LAYOUT LUB WIZUALNE ASPEKTY przed następnym malowaniem.

useEffect jest ASYNCHRONICZNY i nie blokuje przegladarki przed "malowaniem".


useLayoutEffect jest SYNCHRONICZNY. Odpala sie od razu po tym jak 
React wykonal wszystkie zmiany w DOM. Uruchomi sie podczas kazdego rendera,
ale przed tym jak ekran zostanie zaktualizowany.

Jak dziala useEffectLayout ?

1. Re-render zostal wymuszony przez reactowy komponent
2. React renderuje component
3. useLayoutEffect odpala sie synchronicznie
4. React czeka, kiedy useLayoutEffect skonczy dzialanie.
5. Ekran zostaje zaktualizowany.


useLayoutEffect jest uzyteczy, gdy musimy dokonac zmiany w DOMie
a zmiany maja byc widoczne dla uzytkownika
NATYCHMIASTOWO, przed tym jak cokolwiek innego zostanie załadowane.

useLayoutEffect gwarantuje, ze mierzymy DOM po jego aktualizacji, 
ale zanim uzytkownik zobaczy zmiany. 
Gwarantuje to dokładnośc bez powodowania ponownego renderowania.

Prowadzi on do lepszej wydajnosci, poniewaz umozliwia przegladarce 
prioretyzacje aktualizacji zmian na ekranie.

PODSUMOWANIE:

Roznica pomiedzy useEffect i useLayoutEffect w Reactcie polega
na ich odmiennym czasie wywołania. 

W wiekszosci przypadków useEffect będzie wystarczajcym przypadkiem,
jeśli efekt nie wymaga natychmiastowej synchronizacji z DOM.

Czas wykonywania: useEffect jest uruchamiany po namalowaniu aktualizacji na ekranie, natomiast useLayoutEffect jest uruchamiany przed namalowaniem aktualizacji.

Zastosowanie: useEffect jest 
używany do efektów ubocznych, 
które nie wpływają bezpośrednio n
a wygląd komponentu (np. pobieranie danych),
 podczas gdy useLayoutEffect jest używany, 
 gdy trzeba zsynchronizować DOM 
 przed jego namalowaniem (np. manipulacja DOM).

 

 Top 6 błędów Reactowców 

1. Uzywanie useState, gdy jest to kompletnie zbędne

Doytyczy to przypadków, gdy mozemy np miec dostęp
do danych z inputa np email i username.
Zamiast state'a mozna uzyc useRef, które nie re-renderuja
formularza, gdy email badz username zostało zmienione.

Tak samo tyczy się to w przypadku, gdy trzeba wysłac
formularz do serwera. Mozna uzyc formData, zamiast stanu.


2. Nie uzywanie funkcyjnej wersji useState'a

// Count zaktualizuje się wyłącznie raz,
// dlatego, ze React kolejkuje aktualizacje stanu
// Gdy drugi setCount zostaje odpalony to jeszcze poprzedni setCount
// nie zostanie ukończony, wiec wartosc licznika sie nie zmieni.


3. State nie aktualizuje się natychmiastowo

Gdy updatuje zmienna stanu, to ona nie zaktualizuje sie natychmiastowo.
Zostanie zaktualizowana do następnego renderu.

4. Niepotrzebne useEffect'y


useEffect DEEP-DIVE- https://overreacted.io/a-complete-guide-to-useeffect/

Kazdy render ma swoje props'y i state

Kiedy aktualizujemy stan, React wywoluje komponent. 
Kazdy rezultat rendera "widzi" swoja wlasna wartosc licznika

Gdy uzywamy setCount, React wywoluje komponent znowu z innym
licznikiem stanu. Nastepnie React updatuje DOM aby dopasowac ostatni 
render do outputu.


Kluczowa informacja jest taka, ze zmienna count wewnatrz kazdego rendera jest inna.



KAZDY RENDER NA SWOJE WLASNE OBSLUGI ZDARZEN (Event Handlers)


Zmienna count w powyzszych przykladach jest STALA
dla konkretnego wywolania funkcji.

FUNKCJA ZOSTAJE WYWOLANA WIELE RAZY (RAZ NA RENDER)
ALE ZA KAZDYM RAZEM ZAWARTA W NIM WARTOSC COUNT JEST STALA
I USTAWIONA NA OKRESLONA WARTOSC (STAN DLA TEGO RENDERU).


Wiec kazdy render zwraca wlasna "wersje" handlerAlertClicka.

Kazda z tych wersji "pamieta" wlasna wartosc count.


KAZDY RENDER MA SWOJE WLASNE EFEKTY
Efekty odpalaja sie po kazdym renderowaniu
Jak efekt czyta najnowsza wersje wartosc count ?

Count nie zmienia sie w efekcie, to kazdy 
EFEKT JEST W PEWIEN SPOSÓB INNY NA KAZDY RENDER

KAZDA FUNKCJA useEffect() nalezy do konkretnego
rendera, na tej samej zasadzie jak obslugi zda-
rzen (Event Handlers)

                RECAP

React: Zapodaj mi UI gdy state jest 0

Mój komponent: Oto rezultat renderowania:
<p>You clicked 0 times</p>

Zapamietaj rowniez aby odpalic ten efekt, gdy skonczysz: 
()=>{document.title= 'You clicked 0 times'}

React: Jasne, aktualizuje UI. Hej, Przegladarka... Dodaje cos do DOM

Przegladarka: Spoks, namalowalam to na ekranie.

React: Spoko, teraz odpalam efekt, ktory Ci dalem: ()=>{document.title= 'You clicked 0 times'}


                AFTER CLICKING:

Mój komponent: ustaw stan na 1

React: Daj mi UI, gdy state jest 1

Mój komponent: Oto rezultat rendera: <p>You clicked 1 times</p>

React: Pamietaj jeszcze, zeby odpalic efekt, jak skonczysz: ()=>{document.title="You clicked 1 times"}

React: Jasne, Aktualizuje UI. Hej przegladarka, zmienilem DOM.

Przegladarka: Spoko, Namalowalam Twoje zmiany na ekranie.

Kazdy render ma swoje wlasne... WSZYSTKO



PLYWANIE POD PRAD

Kazda funkcja wewnatrz renderowania komponentu( wlaczajac obslugi zdarzen, efekty, timeouty, wywolania API wewnatrz nich) przechwytuje propsu i state tego wywolania, ktory je zdefiniowalo.


Nie ma znaczenia, czy czytasz z wlasciwosci, czy stwierdzasz "wczesnie" w swoim komponencie.
ONE SIE NIE ZMIENIA!!!

Wewnatrz zakresu scope'a pojedynczego renderowania wlasciwosci i stan sprawiaja takie same. 

Oczywiscie, czasami chce sie przeczytac najnowsza wartosc, a nie przechwycona wewnatrz jakiegoś callbacka w efekcie. Najlepszym wyjsciem bedzie uzycie useRef().


CLEAN UP

Celem clean-upowych funkcji jest "cofniecie " efektu w przypadkach takich jak 
subskrybcje

Funkcja clean-upowa nie czyta najnowszyvh propsow. Czyta propsy nalezace do 
renderam, w ktorym jest renderowane.

czyli np.
# First render, props are {id:10}
    function Example(){
        useEffect(()=>{
            # Effect from the first render
            ChatAPI.subscribeToFriendStatus(10, handleStatusChange);
            # Cleanup from first render
            return ()=>{
                ChatAPI.unsubscribeFormFriendStatus(10, handleStatusChange)
            }
        })
    }
# Second render, props are {id:20}
    function Example(){
        useEffect(()=>{
            # Effect from second render
            ChatAPI.subscribeToFriendStatus(20,handleStatusChange)
            # Cleanup for effect from second render
            return ()=>{
                ChatAPI.unsubscribeFormFriendStatus(20, handleStatusChange)
            }
        })
    }

Uczenie Reacta do roznicowania swoich efektow

Gdy updatuje 
<h1 className="Greeting">Hello, Zbyszek </h1>

<h1 className="Greeting">Hello, Yuzhi</h1>

React widzi dwa obiekty:

const oldProps={className:"Greeting", children:"Hello, Zbyszek",}
const newProps={className:"Greeting", children:"Hello, Yuzhi",}}}


Deps

useEffect(()=>{
    document.title="Hello",'' + name;
},[name])

To jest tak, jakby mu powiedziec: "Sluchaj, Ja wiem, ze nie widzisz tego co jest
w tej funkji, ale obiecuje Ci, ze uzywa ona imienia i nic poza zakresem renderujacym"

const oldEffect= ()=>{document.title="Hello, Dan"};
const oldDeps=["Dan"]

const newEffect=()=>{document.title="Hello, Dan"}
const newDeps=["Dan"]

# React nie moze zajrzec do funkcji, ale moze porownac depsy.
# W tym przypadku depsy sa takie same, wiec nie musi odpalac nowego efektu.

• JESLI NAWET JEDNA WARTOSC W TABLICY ZALEZNOSCI JEST INNA POMIEDZY RENDERAMI,
TO WIEMY ZE NIE MOZNA OPUSCIC ODPALENIA TEGO EFEKTU. TRZEBA WSZYSTKO SYNCHRONIZOWAC

NIE OKLAMUJ REACTA W SPRAWIE TABLICY ZALEZNOSCI

* Jesli okreslisz zaleznosci w deps array, to WSZYSTKIE 
wartosci uzywajace tego efektu w Twoim komponencie MUSZA SIE W NIEJ ZNALEZC(propsy,
states, funkcje)


Co sie dzieje, podczas klamania tablicy zaleznosci

useEffect(()=>{
    document.title="Hello", '' + name
},[]) # Wrong: name is missing in deps

(Deps are equal, so we skip the effect)

Function Counter(){
    const [count, setCount]= useState(0);

    useEffect(()=>{
        const id= setInterval(()=>{
            setCount(count+1);
        }, 1000)
        return ()=>{
            clearInterval(id)
        }
        return <h1>{count}</h1>
    },[]) #Depsy sa rowne wiec pomijamy efekt
}

# Uzywajac pustej tablicy zaleznosci stworzy ona buga. React porowna zaleznosci,
# i ominie wykonywanie tego efektu


Dwa wyjscia, jak sobie radzic z zaleznosciami 

Pierwsza strategia jest naprawienie tablicy zaleznosci by zawierala wszystkie wartosci
wewnatrz komponentu, ktore sa uzywane wewnatrz efektu.

    useEffect(()=>{
        const id= setInterval(()=>{
            setCount(count+1);
        }, 1000)
        return ()=>{
            clearInterval(id)
        }
        return <h1>{count}</h1>
    },[count ])
}

Dodano count do tablicy zaleznosci, wiec bedzie odpalac ten efekt, a kazdy
nastepny interwal bedzie odwolywal sie do licznika z jego renderowania w setCount(count+1);

# First render, state is 0
function Counter() {
  #// ...
  useEffect(
   #  Effect from first render
    () => {
      const id = setInterval(() => {
        setCount(0 + 1); // setCount(count + 1)
      }, 1000);
      return () => clearInterval(id);
    },
    [0] // [count]
  );
  # ...
}

# Second render, state is 1
function Counter() {
  # ...
  useEffect(
# Effect from second render
    () => {
      const id = setInterval(() => {
        setCount(1 + 1); # setCount(count + 1)
      }, 1000);
      return () => clearInterval(id);
    },
    [1]# [count]
  );
  # // ...
}

# Making effects self-sufficient (samowystarczalny)


# JWT

# JSON Web Token to bezpieczny sposób przesylania informacji pomiedzy czesciami jako obiekt JSON
# Ta informacja jest godna zaufania, poniewaz jest sygnaturowana cyfrowo.

#JWT Sklada sie z Naglowka, Payloadu i Podpisu (Signature)

# Header zawiera informacje o typie tokena, jak i algorytmu uzywanego do podpisywania i enkodowania

# Payload zawiera informacje (Issuer, Subject, Audience, Expiration TIme, Issued At)

# Signature to typ Base64url encodi